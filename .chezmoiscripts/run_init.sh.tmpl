#! /usr/bin/env bash

set -e

[ -z "$SET_X" ] || env | grep -E 'chezmoi|^CZ'
cd "$CHEZMOI_SOURCE_DIR"
#CZ_MODEL="$(ioreg -l | grep "product-name" | sed -Ee 's/^.*\<"(.*)\"\>.*$/\1/')"
${SET_X:-:} | grep '^CZ_' || true
printf 'System detected as %s/%s, setting up .chezmoiroot and initializing...\n' "$CZ_SYS" "$CZ_CHASSIS"
${SET_X:-:} -x
CZROOTLINK=chezmoi.roots/__root_links/base.chezmoiroot
if [ -r "${CZROOTLINK}.$CZ_SYS.$CZ_CHASSIS" ]; then
    ln -s "${CZROOTLINK}.$CZ_SYS.$CZ_CHASSIS" .chezmoiroot
elif [ -r "${CZROOTLINK}.$CZ_SYS" ]; then
    ln -s "${CZROOTLINK}.$CZ_SYS" .chezmoiroot
elif [ -r "${CZROOTLINK}.$CZ_CHASSIS" ]; then
    ln -s "${CZROOTLINK}.$CZ_CHASSIS" .chezmoiroot
else
    printf 'Failed to find a matching .chezmoiroot. Aborting!\n'
    false
fi

# Function to get relative path without realpath or python
relpath() {
    local target=$1
    local base=$2
    local target_abs=$(cd "$(dirname "$target")" && pwd)/$(basename "$target")
    local base_abs=$(cd "$base" && pwd)
    local common_part="$base_abs"
    local back=""

    while [[ "${target_abs#$common_part}" == "$target_abs" ]]; do
        common_part=$(dirname "$common_part")
        back="../$back"
    done

    echo "${back}${target_abs#$common_part/}"
}

safe_backup() {
    local BASE="${BASE:-$HOME/.cache/chezmoi/init_backup}"
    while [ -n "${1}" ]; do
        local relp="./$(relpath "${1}" ~)"
        [ -r "${1}" ] && mkdir -p "${BASE}/${relp%/*}" && cp ${CPOPTS:-} "${1}" "${BASE}/${relp}"
        shift
    done
}
if ! [ -d ~/.cache/chezmoi/init_backup ]; then
    safe_backup ~/.zshrc ~/.zsh_history ~/.zprofile ~/.bashrc ~/.bash_history ~/.profile
fi

# Brute force remove chezmoistate lock and restart init --apply
exec sh -c 'rm ~/.config/chezmoi/chezmoistate.boltdb && CZ_EXTR=1 chezmoi init --apply'
