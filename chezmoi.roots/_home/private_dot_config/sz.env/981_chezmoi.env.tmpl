#"!/usr/bin/env -S bash -c 'echo "Not a user script. source(aka .) only"'
# shellcheck disable=SC1090

if is_cmd 'chezmoi' && (chezmoi --version 2>&1) > /dev/null; then
    alias cz='PAGER="${CZ_PAGER:-${PAGER:-}}" chezmoi '
    alias ll-cz='ll --color=always | grep -v remove_ '

    eval "$( chezmoi completion "${SHELL##*/}" | sed -Ee 's/(complete -o default .* chezmoi)/\1 cz/' )"

    export CHEZMOI_GITHUB_ACCESS_TOKEN={{- .githubToken | quote }}

    CZG_ROOT="$(chezmoi git -- rev-parse --show-toplevel)"
    alias czg="git --work-tree=$CZG_ROOT --git-dir=$CZG_ROOT/.git "
    unset CZG_ROOT

    complete -F _complete_alias czg

    alias czs="chezmoi status "
    alias cza="chezmoi apply "

    __cz_expand() {
        eval "printf '%s\n' $( 
            sed -Ee '
                s|^M: (.*)$|"\$(cz source-path ~/"\1")"|; 
                s|^U: |~/|; s|$| \\|
            '
        )"
    }
    cz-get-files () {
        #set -euo pipefail

        local managed unmanaged all_files
        # Collect managed and unmanaged; combine and dedupe
        managed="$(cz managed --exclude=remove,dirs,externals || true)"
        unmanaged="$( cz unmanaged --nul-path-separator | grep -Ev '\.zwc$' \
            | xargs -r0I{} sh -c 'printf "%s%s\n" "{}" "$(stat ~/"{}" | grep -Eo "^[[:digit:]]+ [[:digit:]]+ ." | grep -Eo ".$" | sed -Ee "s|d\$|/|; s|[^/]\$||;" || true )"'
        )"
        all_files="$( (
            <<<"$managed" sed 's/^/M: /';
            <<<"$unmanaged" grep -Ev '/$' | sed 's/^/U: /'
            ) | sort -Vk'2,2' )"

        # If no args: just fuzzy-pick from all (multi-select)
        if [ "$#" -eq 0 ]; then
            if ! is_cmd tv >/dev/null 2>&1; then
                echo "Error: tv not found (needed for interactive fuzzy selection with no args)" >&2
                return 2
            else
                <<<"${all_files}" tv --preview-command="cat ~/'{1}' || stat ~/'{1}'"
                return 0
            fi
        fi

        # Process args
        local singles multi_candidates
        declare -a singles=()             # resolved to one match or passed as-is when no match
        declare -a multi_candidates=()    # accumulate ambiguous matches to fuzzy-pick from

        for arg in "$@"; do
            # Substring match (literal). Switch grep -F to -E if you want regex patterns.
            matches="$(<<<"$all_files" grep -E -- "^.: (.*/)?$arg\$" || true)"
            [ -n "$matches" ] || matches="$(<<<"$all_files" grep -E -- "^.: .*$arg.*\$" || true)"
            if [ -z "$matches" ]; then
                # No match at all: pass arg as-is
                singles+=("$arg")
            else
                count=$(printf "%s\n" "$matches" | wc -l | tr -d '[:space:]')
                if [ "$count" -eq 1 ]; then
                    singles+=("$(<<<"$matches")")
                else
                    multi_candidates+=("$arg")
                fi
            fi
        done

        # If there are ambiguous matches, fuzzy-pick from their unique set
        declare -a picked=()
        if [ "${#multi_candidates[@]}" -gt 0 ]; then
            if ! is_cmd tv >/dev/null 2>&1; then
                echo "Error: tv not found (needed for disambiguating multiple matches)" >&2
                # Still output the resolved singles even if we cannot disambiguate
                printf "%s\n" "${singles[@]}" | uniq
                return 3
            fi
            # Let user multi-select with fzf (empty selection allowed)
            while IFS= read -r arg; do
                <<<"$all_files" \
                tv --input-prompt="'$arg'?> " --preview-command="cat ~/'{1}'" --input="$arg" \
                || true
            done <<<"$(printf "%s\n" "${multi_candidates[@]}" | uniq )"
        fi

        # Combine singles + picked, make unique, and output
        printf "%s\n" "${singles[@]}" "${picked[@]}" | uniq
    }

    chezmoi() {
        ${SET_X:-:} -x
        case "$1" in
            cd) cz-cd "${2}" ;;
            apply) ${CZA:-env} chezmoi apply "${2---less-interactive}" "${@:3}"  ;;
            edit) 
                local FILES="$(cz-get-files "${@:2}")"
                [ -n "$FILES" ] \
                && ${VISUAL:-${EDITOR:-vi}} $(<<<"$FILES" __cz_expand) \
                && (${CZA:-env} chezmoi apply --interactive $(<<<"$FILES" sed -Ee 's|^.: |~/|'))
            ;;
        #   source-path) printf '%s\n' "${@:2}" | xargs -r env chezmoi source-path ;;
            *) env chezmoi "${@}" ;;
        esac
        ${SET_X:-:} +x
    }
    cz-cd() { cd "$(chezmoi source-path ${1})"; }
    czgcd() {
        cd "$(SET_X=':' chezmoi git -- rev-parse --show-toplevel)${1:+/${1}}"
    }
    czedext() {
        local CZ_EXT="$(find $(SET_X=':' chezmoi source-path) -mindepth 1 -maxdepth 1 -name '.chezmoiexternal.*')"
        CZ_EXT="${CZ_EXT:-$(SET_X=':' chezmoi source-path "${@}")/.chezmoiexternal.yaml.tmpl}"
        "${VISUAL:-${EDITOR:-vi}}" "${CZ_EXT}"
    }
    czedignore() {
        local CZ_IGN="$(find $(SET_X=':' chezmoi source-path) -mindepth 1 -maxdepth 1 -name '.chezmoiignore*')"
        "${VISUAL:-${EDITOR:-vi}}" "${CZ_IGN}"
    }
    czed() {
        local EDITLIST=() f _f
        for _f in "${@}"; do
            [[ -e "$_f" ]] || f="$(which "$_f")"
            [[ -z "$f" ]] && is_cmd tv && f="$(tv "$_f")" || f=$_f
            EDITLIST=( "${EDITLIST[@]}" "$f" )
        done
        EDITLIST=("${@}")
        chezmoi edit "${EDITLIST[@]}" --apply --less-interactive
    }
    czedenv(){
        local CZ_ENV="$(find $(SET_X=':' chezmoi source-path) -mindepth 2 -maxdepth 2 -type f,l -name 'szEnv.yaml')"
        local CZ_CFG="$(find $(SET_X=':' chezmoi source-path) -mindepth 1 -maxdepth 1 -name '.chezmoi.*')"
        "${VISUAL:-${EDITOR:-vi}}" "${CZ_ENV}" "${CZ_CFG}"
    }
    # CZ_EXTR is evaluated in .chezmoiexternal.yaml.
    # By default, a very small portion of the externals are being
    # evaluated, when CZ_EXTR is set to 1, full evaluation of the
    # externals yaml is performed.
    alias czx="CZ_EXTR=1 chezmoi "
    alias czxs="czx status --include externals"
    alias czxa="czx apply --include externals"

    function czu() {
        [ -r "$SZ_ENV_ROOT/lib/czu.sh" ] || return 2
        . "$SZ_ENV_ROOT/lib/czu.sh"
    }
    alias czxu="cz upgrade && czg pull && cz init --verbose && czx apply --verbose && _r"
    alias cz-reset-home="(czgcd && cd chezmoi.roots && RESET=reset SRC_DIR=_src.all ./symclone.sh _home && RESET=reset ./symclone.sh _home.macos)"
fi

# vim: set ft=sh sw=4 sts=4 et:
