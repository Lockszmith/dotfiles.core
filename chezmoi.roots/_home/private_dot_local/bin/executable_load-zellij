#! /usr/bin/env bash

# Helper function
is_sourced() {
    if [ -n "$ZSH_VERSION" ]; then 
        case $ZSH_EVAL_CONTEXT in *:file:*) return 0;; esac
    else  # Add additional POSIX-compatible shell names here, if needed.
        case ${0##*/} in dash|-dash|bash|-bash|ksh|-ksh|sh|-sh) return 0;; esac
    fi
    return 1; # NOT sourced.
}

BASE_0=${BASE_0:-$0}
BASE_SHELL="${BASE_SHELL:-$(basename "$SHELL")}"

if is_sourced; then
    zellij-cleanup() {
        env which zellij > /dev/null && command -v zellij | grep -E "^$HOME" | ${SUDO:-} xargs -tr rm
        local _cache_dirs=("$HOME/.cache" "$HOME/Library/Caches/" "${TMPDIR}" "/tmp")
        for cache_dir in "${_cache_dirs[@]}"; do
            [[ -n "$cache_dir" && -d "$cache_dir" ]] || continue

            find "$cache_dir" -maxdepth 1 -mindepth 1 -type d -iname '*zellij*' -print0 | ${SUDO:-} xargs -r0t rm -fR
        done

        if [[ "$(find "$cache_dir" -maxdepth 1 -mindepth 1 -type d -iname '*zellij*' | wc -l)" -gt 0 ]]; then
            printf 'Zellij cleanup failed to remove the cache directory, you might still have a zellij session active.\n'
        else
            printf 'Zellij has been cleaned up, you can now reinstall it.\n'
            unset -f zellij-cleanup
        fi
    }
    refresh-zellij() {
${SET_X-:} -x
        local bin_path=~/.local/bin/zellij
        local cached_path=~/.cache/chezmoi/tmp/zellij
        if [ -z "$(command -v zellij)" ] && [ -x "${cached_path}" ]; then
            printf "Grabbing zellij from the cache!\n"
            cp "${cached_path}" "${bin_path}"
        fi
        local cached_path=${TMPDIR:-/tmp}/zellij/bootstrap/zellij
        if [ -z "$(env which zellij)" ] && ! [ -x "${bin_path}" ]; then
            if [[ ! -r "${cached_path}" ]]; then
                printf "Grabbing zellij from the web!\n"
                bash <(curl -sL zellij.dev/launch) "--help" > /dev/null 2>&1 || true
            fi
            if [[ -r "${cached_path}" ]]; then
                mv "${cached_path}" "${bin_path}"
                rm -fR ${TMPDIR:-/tmp}/zellij
            fi
        fi
        refresh-zellij() { :; }
    }
    zellij() {
        refresh-zellij
        if [[ $# -eq 0 ]]; then
            env zellij attach -c $USER@$(hostname)
        else
            env zellij "${@}"
        fi
    }

    zellij-load-completion() {
        if [[ "${BASE_SHELL}" == "zsh" ]]; then
            type _zellij > /dev/null \
            || . <( env zellij setup --generate-completion zsh | sed -Ee 's/^(_(zellij) ).*/compdef \1\2/' )
        else
            . <( env zellij setup --generate-completion "$BASE_SHELL" )
        fi
    }

    zellij-toggle-autoload() {
        if [[ -n "$ZELLIJ_SESSION_NAME" ]]; then
            if [[ "$ZELLIJ_SESSION_NAME" == "dont_load" ]]; then
                unset ZELLIJ_SESSION_NAME
                printf "ZELLIJ_SESSION_NAME was unset.\n"
            else
                printf "Seems like you're in a zellij session ('%s'), you must exit it first.\n" >&2
            fi
        else
            export ZELLIJ_SESSION_NAME=dont_load
            printf "ZELLIJ_SESSION_NAME was set, zellij will not start automatically.\n"
        fi
    }

    zellij-mode() {
        local BASE="config.kdl" ROOT=~/.config/zellij
        local SRC="${BASE}.${1:?Mode missing}"
        [[ -s "${ROOT}/${SRC}" ]] \
        || ( printf 'Mode "%s" must exists!\n' "${1}" >&2; return 1 )
        [[ -L "${ROOT}/${BASE}" || ! -e "${ROOT}/${BASE}" ]] \
        || ( printf 'config.kdl is an actual file, will not replace\n' >&2; return 2 )
        if [[ "$RESET" == 'reset' ]]; then
            [[ -e "${ROOT}/${BASE}" ]] && rm "${ROOT}/${BASE}"
            cp "${ROOT}/${SRC}" "${ROOT}/${BASE}"
        else
            (cd "${ROOT}"; ln -sf "${SRC}" "${BASE}")
        fi
    }
${SET_X-:} -x
    if [[ -n "$(env which zellij)" ]]; then
        zellij-load-completion
    fi
${SET_X-:} -x
    # Was needed when zsh would load
    # . <( zellij setup --generate-completion "$BASE_SHELL" | sed -ne '/^function/,$p' )
    if [[ -z "$ZELLIJ_SESSION_NAME" ]]; then
        zellij attach -c $USER@$(hostname)
    fi

elif [[ "$1" == '-' ]]; then
    cat "${BASH_SOURCE[0]}"
else
    SCRIPT_NAME="$BASE_0"
    printf '%s\n' \
        "It seems $SCRIPT_NAME was invoked as a script. It should be sourced instead." \
        'The easiest way is to call it like this:' \
        "    $ . <( $SCRIPT_NAME - ) # Note the '-' after the script's name" \
        ''
fi

# vim: set ft=sh expandtab tabstop=4 shiftwidth=4:

