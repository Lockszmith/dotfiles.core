#! /usr/bin/env bash

set -euo pipefail

is_cmd() { type -p -- "${@}" 2> /dev/null 1> /dev/null; }

all_files="$(SET_X=: cz get-all-files )"

${SET_X:-:} -x
# If no args: just fuzzy-pick from all (multi-select)
if [ "$#" -eq 0 ]; then
    if ! is_cmd tv >/dev/null 2>&1; then
        echo "Error: tv not found (needed for interactive fuzzy selection with no args)" >&2
        exit 2
    else
        <<<"${all_files}" tv --preview-command="cz preview '{1}'"
        exit 0
    fi
fi

# Process args
declare -a singles=()             # resolved to one match or passed as-is when no match
declare -a multi_candidates=()    # accumulate ambiguous matches to fuzzy-pick from

for arg in "${@}"; do
    # Substring match (literal). Switch grep -F to -E if you want regex patterns.
    matches="$(<<<"$all_files" grep -E -- "^.: (.*/)?${arg}\$" || true)"
    [ -n "$matches" ] || matches="$(<<<"$all_files" grep -E -- "^.: .*${arg}.*\$" || true)"
    if [ -z "$matches" ]; then
        # No match at all: pass arg as-is
        singles+=("${arg}")
    else
        count=$(printf "%s\n" "$matches" | wc -l | tr -d '[:space:]')
        if [ "$count" -eq 1 ]; then
            singles+=("$matches")
        else
            multi_candidates+=("${arg}")
        fi
    fi
done

# If there are ambiguous matches, fuzzy-pick from their unique set
declare -a picked=()
if [ "${#multi_candidates[@]}" -gt 0 ]; then
    if ! is_cmd tv >/dev/null 2>&1; then
        echo "Error: tv not found (needed for disambiguating multiple matches)" >&2
        # Still output the resolved singles even if we cannot disambiguate
        printf "%s\n" "${singles[@]}" | uniq
        exit 3
    fi
    # Let user multi-select with fzf (empty selection allowed)
    while IFS= read -r arg; do
        while read -r _sel; do
            [ -z "$_sel" ] || picked+=("$_sel")
        done <<<"$( <<<"$all_files" \
            tv --input-prompt="'${arg}'?> " --preview-command="cz preview '{1}'" --input="${arg}" \
            || true )"
    done <<<"$(printf "%s\n" "${multi_candidates[@]}" | uniq )"
fi

# Combine singles + picked, make unique, and output
printf "%s\n" "${singles[@]}" "${picked[@]}" | uniq | grep -Ev '^$' \
    | sed -Ee 's|^([UM]: )?|\1~/|; s|~/([~/])|\1|; s|\$|\\$\\|g; s|^([UM]: )?~/|\1$HOME/|' \
    | envsubst | sed -Ee 's|\\\$\\|$|g'
# | sed -Ee 's|^([UM]: )?|\1~/|; s|~/([~/])|\1|; s|\$|\\$\\|g; s|^([UM]: )?~/|\1$HOME/|' | envsubst | sed -Ee 's|\\\$\\|$|g'

${SET_X:-:} +x
# vim: set ft=sh sw=4 sts=4 et:
